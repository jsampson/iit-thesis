This is the code for my forthcoming master's thesis, Integrated Information
Theory of Consciousness in Conventional Computing.

The "circ" subdirectory contains a circuit simulator used to generate all the
circuit timing diagrams in the thesis. It is run as circ/main.py <file>, where
<file> is one of the output filenames: idealized.tex, jagged.tex, flatline.tex,
or clocked.tex. The output is a TikZ picture for use in a LaTeX document.

The root directory contains an emulator and dataflow analyzer for the toy
computer design described in the thesis. The toy computer contains three
registers:

* A: The current state of the simulated system. Up to 64 individual bits.
* B: The partially-computed next state of the simulated system. Same size as A.
* I: The instruction pointer. Up to 8 bits, interpreted as a binary number.

The toy computer implements these six instructions:

Instruction | Operation      | Semantics
------------|----------------|------------------------------------------------
JMP +x      | Jump           | If (x>0) then {I:=I+x} else {A:=B; B:=0; I:=0}.
SKZ #x      | Skip if zero   | If (A[x]==0) then {I:=I+2} else {I:=I+1}.
CLR #x      | Clear bit      | {B[x]:=0; I:=I+1}.
SET #x      | Set bit        | {B[x]:=1; I:=I+1}.
END         | End macro step | Abbreviation for JMP +0.
NOP         | No operation   | Abbreviation for JMP +1.

At the start of each iteration of a program, B and I will be zero while A can
have any starting state. Each program runs until an END instruction and then
repeats from the beginning.

The run.py script has six running modes:

run.py <file> <state>

    Runs the toy computer with the given program continuously, starting from
    the given initial state.

run.py <file>

    Analyzes the given program in various ways.

run.py <file> phi

    Analyzes the given program as before, and also calculates IIT's phi value
    for every macro state (assuming that each bit is a valid macro element).

run.py <file> micro [<state>]

    Generates Python code for calculating phi for the micro-causal model of
    the toy computer with the given toy program, containing appropriate tpm,
    cm, and state arrays plus the code to invoke PyPhi. The state argument is
    optional and defaults to an all-zero value. It is formatted as AAABBBIIIII,
    where there are just as many A, B, and I bits as are needed for the program
    and they are all in little-endian order.

run.py <file> micro phi

    Produces the same causal model and also attempts to calculate phi for each
    of its micro states. Warning: This command is unlikely to complete running
    in a reasonable timeframe.

run.py <file> diagram

    Produces a LaTeX diagram of the program, its control flow, and "black box"
    analysis.

In each of those, <file> can be the name of a file containing a program in the
toy computer's assembly language, or it can be "-" to read from the standard
input. If given, <state> is a binary number (e.g. "101") specifying the initial
state of the computer, in little-endian format as is conventional for the IIT
literature.

The commands without "phi" do not require anything beyond the standard library
packages of Python 3. The commands with "phi" require PyPhi to be installed.
The Dockerfile is provided to ensure that PyPhi and its dependencies can be
installed successfully. The build-image.sh and run-all.sh scripts build the
image and run it on all of the provided example programs, respectively.

The various *.txt files are example programs as describe in the thesis:

pqr.txt

    A straightforward implementation of the "PQR" system.

xor3.txt

    Three XOR gates, where the inputs to each one are the outputs from the
    other two.

counter.txt

    A four-bit counter.

optimized.txt

    The PQR system, but with some reads shared between blocks.

tree.txt

    The PQR system, but implemented as a full state transition table using a
    branching tree structure.

tree-b0.txt

    A variant of tree.txt where all of the CLR instructions are removed
    because they are redundant given that B=0 at the start of the program.

tree-b0-opt.txt

    A hand-optimized version of tree-b0.txt that extracts common code
    between branches and eliminates the JMP for single-instruction branches.

pqrpqr.txt

    Two copies of the PQR system running in a single computer.

unrolled-circuit.txt

    Simulating an 11-bit system that contains 8 bits for the actual states
    and 3 bits that appear to functionally imitate the PQR system.

unrolled-short-circuit.txt

    A variant implementation of unrolled-circuit.txt that immediately
    converges to a single state bit being on if it starts with more than
    one.


Copyright 2022 by Justin T. Sampson
